<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VuePress</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.021a0155.css" as="style"><link rel="preload" href="/assets/js/app.a2c87e9d.js" as="script"><link rel="preload" href="/assets/js/4.1d40237b.js" as="script"><link rel="prefetch" href="/assets/js/2.61c5963e.js"><link rel="prefetch" href="/assets/js/3.ccb79862.js">
    <link rel="stylesheet" href="/assets/css/0.styles.021a0155.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><!----></div></header><div class="sidebar-mask"></div><div class="sidebar"><!----><!----></div><div class="page"><div class="content"><p>Toro always tries to work well with RecyclerView, and ExoPlayer 2 (below: ExoPlayer). In previous release (3.6.x), I provided a mechanism to cache and reuse some expensive objects including ExoPlayer instance. In this mechanism, ExoPlayer instances are cached using a Pool that is mapped to a Config. This config gives the ExoCreator some cached resources to create the ExoPlayer on-demand, as well as MediaSource instance. There are, to be honest, some issue hiding inside the caching method, and also some error-prone there. If you could follow the development close enough, I guess you may be able to point out some, like below:</p><ul><li><p>As the Config has a BaseMeter (which is simply a combination of a BandwidthMeter and a TransferListener), this BaseMeter will be reused to create many ExoPlayer instances. In fact, <a href="https://github.com/google/ExoPlayer/issues/3705#issuecomment-357620806" target="_blank" rel="noopener noreferrer">this comment<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> suggests that using same BandwidthMeter among multiple ExoPlayer instances is not a good idea (though we may actually have only one active play at a time).</p></li><li><p>The mechanism may work well on non-DRM content, as we may need only one Config, and therefore one ExoCreator and so on. But it may not work well on DRM heavy application.</p></li><li><p>Customizing the interfaces is not straight forward. I can say that you have close to zero flexibility when using this mechanism. Even though it may be as easy as extending my default classes, or having composition with default ones, etc, the 'easy to do' way is not so obvious out of the box.</p></li><li><p>If you care about testing, though Toro contains close to zero test case, I still care about how your would do with your app. And to be honest, having global instance of ToroExo prevents you from mocking it for any unit test you may want to do. In shot, Toro is not so testable library.</p></li></ul><p>In 3.7.0, I try to address these issues, and make a huge change in the code base to make it more flexible, yet still being a powerful implementation on top of ExoPlayer to help your life easier.</p><h2 id="review"><a href="#review" aria-hidden="true" class="header-anchor">#</a> Review</h2><p>First, let's get familiar with some important concepts that end up existing in this release (some of them are there in 3.6.x already):</p><h4 id="toroplayer"><a href="#toroplayer" aria-hidden="true" class="header-anchor">#</a> ToroPlayer</h4><p>As you all know, this is the heart of Toro. This interface defines necessary playback behaviors, as well as some constraint to tell the library when to do what. This interface is expected to implemented by a RecyclerView's ViewHolder to work with <strong>Container</strong> (a custom RecyclerView, the brain of Toro).</p><h4 id="toroplayerhelper"><a href="#toroplayerhelper" aria-hidden="true" class="header-anchor">#</a> ToroPlayerHelper</h4><p>This class has the interface simillar to a ToroPlayer, though it can be thought as a delegation of playback behaviour. The purpose is to be consistent with ToroPlayer's API, but on the back, it can adapts various playback API to provide actual behaviour. In my lib, and demo, I show how to extend this class to work with ExoPlayer, Android MediaPlayer and even YoutubePlayer API.</p><h4 id="playable"><a href="#playable" aria-hidden="true" class="header-anchor">#</a> Playable</h4><p>This is a core concept of the extension for ExoPlayer. Its purpose is to connect ExoPlayer's playback API to the ToroPlayerHelper API. Custom ToroPlayerHelper will be built around this interface to connect ExoPlayer with ToroPlayer. The DefaultPlayable is a default implementation. I learnt from ExoPlayer's demo app, as well as tiny bits from others to make this class as powerful as possible. Though, to be honest, there are many rooms for improvement at the moment. You do not need Playable to build custom ToroPlayerHelper that supports ExoPlayer, but you may eventually need one.</p><h4 id="exoplayermanager"><a href="#exoplayermanager" aria-hidden="true" class="header-anchor">#</a> ExoPlayerManager</h4><p>This interface is new in 3.7.0.</p><p>In 3.6.x, I manage the ExoPlayer instances in the global scope of ToroExo. I think that, as playback consumes system's resource, regardless of how your app being constructed, those resource should be manage from root. In 3.7.0, the concern is unchanged, but I change the way to present how to do it.</p><p>ExoPlayerManager has only 3 methods: one to construct an ExoPlayer instance 'from somewhere', one to release the ExoPlayer instance 'to somewhere' and one to clean up everything on demand. The implementation is not limited to anything complicated. You can always create new instance when need, and release it right away.</p><p>My default implementation, on the other hand, divides the usecases in to DRM and non-DRM playback. In non-DRM playback, all the resources can be reused without risk, so I heep a Pool to manage ExoPlayer instances. This helps you to resuse resource as much as you can, without any drop in performance. In DRM playback, on the other hand, I will always create new instances and release the old ones as soon as possible. DRM playback is not easy, not only because there are many constraint, but also it is where your content is secured. I don't want to risk it with bad implementation.</p><p>Once constructed, the ExoPlayerManager instance should be accessible across your App. This way, the resource management is still global. In 2018, when DI (dependencies injection) is becoming common practice to provide resource in your App, ExoPlayerManager could be a part of it: construct the instance from DI, pass it around by DI and you are all set.</p><h4 id="bandwidthmeterfactory"><a href="#bandwidthmeterfactory" aria-hidden="true" class="header-anchor">#</a> BandwidthMeterFactory</h4><p>This interface is new in 3.7.0. Its purpose is to build a new BandwidthMeter when creating a new ExoPlayer instance. As said before, it'd better to have BandwidthMeter to be used by only one ExoPlayer instance. Having a factory will be easy enough to make it. In my default implementation of ExoPlayerManager, it requires a BandwidthMeterFactory to provide BandwidthMeter to the ExoPlayer on demand.</p><h4 id="drmsessionmanagerprovider"><a href="#drmsessionmanagerprovider" aria-hidden="true" class="header-anchor">#</a> DrmSessionManagerProvider</h4><p>This interface is new in 3.7.0. Same as BandwidthMeterFactory, this interface is to build DrmSessionManager when creating a new ExoPlayer instance. Difference to the BandwidthMeter is that, the DrmSessionManager is not always required. So for non-DRM content, this interface just need to return nothing (a.k.a null).</p><h4 id="mediasourcefactoryprovider"><a href="#mediasourcefactoryprovider" aria-hidden="true" class="header-anchor">#</a> MediaSourceFactoryProvider</h4><p>This interface is new in 3.7.0. This is another important component in this release.</p></div><div class="page-edit"><!----><!----></div><!----></div></div></div>
    <script src="/assets/js/4.1d40237b.js" defer></script><script src="/assets/js/app.a2c87e9d.js" defer></script>
  </body>
</html>
